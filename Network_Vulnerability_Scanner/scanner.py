import socket
import sys
import threading
import concurrent.futures
from datetime import datetime
from CVE_db import vulnerabilities

# Starting Configuration - Change this accordingly
# Disclaimer: Scanning networks without permission is illegal.
target_server = "scanme.nmap.org"
target_server_ip = socket.gethostbyname(target_server)
timeout = 1.0
start_num_port = 1
end_num_port = 101
num_threads = 50

# Threading Configuration
printing_lock = threading.Lock()
num_discovered_ports = 0

def welcome_message():
    """Prints the welcome message and general scan details."""
    print("=" * 50)
    print("Welcome to the Network Vulnerability Scanner")
    print("Description: A multi-threaded scanner to discover open ports and their respective Common Vulnerabilities and Exposures (CVEs)")
    print("=" * 50)
    print(f"Target IP Address: {target_server_ip} ({target_server})")
    print(f"Time Started: {str(datetime.now())}")
    print("-" * 50)
    print(f"Scanning ports {start_num_port} - {end_num_port} with {num_threads} threads...")
    print("-" * 50)

def grabbing_banner(s):
    """
    Tries to acquire the banner from the port to get information about the service.
    Returns 'NOT KNOWN' if a banner could not be attained.
    """
    try:
        banner = s.recv(1024).decode().strip()
        if not banner:
            return "NOT KNOWN"
        return banner
    except:
        return "NOT KNOWN"

def check_inside_CVE_db(banner):
    """
    Local CVE database (CVE_db.py) is checked against with the grabbed banner.
    Returns the vulnerability dictionary if a match is found. If no match is found 'None' is returned.
    """
    for version, CVE_data in vulnerabilities.items():
        if version in banner:
            return CVE_data
    return None

def finding_open_ports(port):
    """
    Each thread runs this worker function to check if port is open, attempts to grab the banner and checks for corresponding CVEs.
    """
    global num_discovered_ports

    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        s.settimeout(timeout)
        
        result = s.connect_ex((target_server_ip, port))
        
        if result == 0:
            # Port is open so banner is attempted to be grabbed
            grabbed_banner = grabbing_banner(s)

            with printing_lock:
                # Lock is used so threads print one at a time
                num_discovered_ports += 1
                print(f"#{num_discovered_ports}: Port {port} is OPEN")
                print(f"Service: {grabbed_banner}")

                if not grabbed_banner == "NOT KNOWN":
                    print("")

                    # Check if the grabbed banner is in the CVE database
                    CVE_check = check_inside_CVE_db(grabbed_banner)

                    if CVE_check:
                        print(f"Vulnerability Discovered:")
                        print(f"   - CVE ID: {CVE_check['CVE_id']}")
                        print(f"   - Severity: {CVE_check['severity']}") 
                        print(f"   - Score: {CVE_check['score']}/10.0")
                        print(f"   - Description: {CVE_check['description']}")
                    else:
                        print("Vulnerability is not in the database.")
                        print("Check manually at: https://nvd.nist.gov/vuln/search.")

                print("-" * 50)

            s.close()
            
    except KeyboardInterrupt:
        print("\n Program has been interrupted. Exiting program.")
        sys.exit()

    except socket.error:
        print("\n Server has an error.")
        sys.exit()

def threads_running():
    """
    Threads are managed in this function.
    'num_threads' workers are spawned at once and concurrently run the 'finding_open_ports' function.
    """
    with concurrent.futures.ThreadPoolExecutor(max_workers=num_threads) as runner:
        for port in range(start_num_port, end_num_port):
            runner.submit(finding_open_ports, port)

def main() -> None:
    welcome_message()
    threads_running()

if __name__ == "__main__":
    main()